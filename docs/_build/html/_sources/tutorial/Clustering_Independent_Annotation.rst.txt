CLUSTERING INDEPENDENT ANNOTATION
=================================

**Clustering Independent Annotation** (**CIA**) is a classification
method meant to **help researchers in the cluster annotation step** of
scRNA-seq experiments. Exploiting two functions, given cell type
signatures as input, **this classifier computes a signature score for
each cell** (**signature_score**) **and** (with different modalities)
**it compares the score values in order to assign a label to each single
cell** (**signature_based_classification**).

This tool provides several advantages:

-  It synthesizes the information of **a whole signature expression in a
   single score value**, skipping the tedious one by one inspection of
   single marker genes taken from long differentially expressed genes
   (DEGs) lists, which furthermore may not be cluster specific when
   taken singularly.

-  It provides a classification for each cell that is **completely
   independent from clustering**, thus, it can be used in parallel with
   a clustering method in order to set a proper resolution value,
   obtaining so coherent and easy to annotate cell groups.

-  Given the implemented modalities, **it can be very fast** and
   classify a huge dataset (hundreds of thousands cell) in a bunch of
   seconds, **or it can be statistically more reliable** exploiting the
   comparison of obtained signature scores with randomic signature ones.
   Since the latter method is of course computationally heavier, **we
   implemented the possibility to parallelize processes**.

-  Being signature-based, this tool can provide information about **any
   kind of gene list with a biological meaning**, allowing also
   functional annotation.

-  Normalizing for the gene signature length, it enable the **comparison
   of genesets with different length**, spanning **from tens to
   thousands genes** (obviously with different significance).

CIA is composed by **two main modules**:

-  **investigate**: a module which contains the functions to **compute
   signature scores and automatically annotate cells accordingly**
   (funtions: signature_score and signature_based_classification)
-  **report**: a module which contains the functions to **visualize
   score distributions** in cell groups **and classification
   performances** with respect to a reference annotation (functions:
   group_composition, classification_metrics,
   grouped_classification_metrics and grouped_distributions)

In this tutorial is shown a **representative workflow** in which we
exploited CIA functions to **annotate two scRNA-seq datasets** at
cellular level starting from a set of gene signatures and to **evaluate
the performances** with respect to a independent reference annotation.

.. code:: ipython3

    import numpy as np
    import pandas as pd
    import scanpy as sc
    import seaborn as sns
    import multiprocessing
    from functools import partial
    from scipy.sparse import issparse
    from scipy import sparse
    import time
    from sklearn import metrics
    from scipy import sparse
    import itertools

.. code:: ipython3

    from cia import investigate, report

.. code:: ipython3

    import warnings
    warnings.filterwarnings('ignore')

Extracting gene signatures from PBMC atlas
------------------------------------------

Our method requires as input an **AnnData** object and a **dictionary
containing the names of the signatures** (e.g. cell type, cell state or
cell phase) **as keys and corresponent gene names as values**. For
demonstration purposes we decided to use as signatures the DEGs of Hao
et al 2021
`[1] <https://www.sciencedirect.com/science/article/pii/S0092867421005833>`__
**PBMC atlas obained with CITE-seq method**. This dataset clusters have
been **confidently annotated** exploiting “weighted-nearest neighbor”
framework, an integrative analysis which takes into account both RNA and
protein level information. This approach ensures that the extracted gene
lists (RNA based only) are actually associated to a specific cell type.

.. code:: ipython3

    # to copy and gunzip the data
    !cp ./data/atlas.h5ad.gz  ./data/copy_atlas.h5ad.gz
    !gunzip ./data/copy_atlas.h5ad.gz

.. code:: ipython3

    # to read the atlas data
    atlas= sc.read('./data/copy_atlas.h5ad')
    atlas




.. parsed-literal::

    AnnData object with n_obs × n_vars = 161764 × 20729
        obs: 'nCount_ADT', 'nFeature_ADT', 'nCount_RNA', 'nFeature_RNA', 'orig.ident', 'lane', 'donor', 'time', 'celltype.l1', 'celltype.l2', 'celltype.l3', 'Phase', 'nCount_SCT', 'nFeature_SCT', 'Cell type', 'Predicted cell type', 'B', 'CD4 T', 'CD8 T', 'DC', 'Mono', 'NK', 'Platelet', 'other T', 'Prediction p-val', 'Prediction fast mode', 'Prediction standard mode', 'Prediction q', 'Adjusted prediction fast mode', 'Adjusted prediction standard mode', 'Adjusted prediction q', 'Adjusted prediction p-val', 'B_filtered_FC', 'CD4 T_filtered_FC', 'CD8 T_filtered_FC', 'DC_filtered_FC', 'Mono_filtered_FC', 'NK_filtered_FC', 'Platelet_filtered_FC', 'other T_filtered_FC', 'CD8 T_negative', 'CD4 T_negative'
        var: 'features'
        uns: 'Adjusted prediction fast mode_colors', 'Adjusted prediction p-val_colors', 'Adjusted prediction q_colors', 'Adjusted prediction standard mode_colors', 'Cell type_colors', 'Predicted cell type_colors', 'Prediction fast mode_colors', 'Prediction p-val_colors', 'Prediction q_colors', 'Prediction standard mode_colors', 'celltype.l1_colors', 'celltype.l2_colors', 'celltype.l3_colors', 'neighbors', 'signature_based_classification'
        obsm: 'X_apca', 'X_aumap', 'X_pca', 'X_spca', 'X_umap', 'X_wnn.umap'
        varm: 'PCs', 'SPCA'
        obsp: 'distances'



.. code:: ipython3

    # to remove the gunzipped data
    !rm  ./data/copy_atlas.h5ad 

.. code:: ipython3

    # to set AnnData.raw
    atlas.raw=atlas

This dataset has been annotated at **3 different levels of
granularity**. We focused on the coarser one both for visualization
purposes and to facilitate the comparisons with other datasets annotated
at lower resolution.

.. code:: ipython3

    sc.pl.umap(atlas, color='celltype.l1')



.. image:: output_14_0.png


.. code:: ipython3

    sc.pl.umap(atlas, color=['celltype.l2', 'celltype.l3'], wspace=1)



.. image:: output_15_0.png


Since labels ‘other’ and ‘other T’ don’t refer to any cell type in
particular we checked their identity in the higher resolution
annotation.

.. code:: ipython3

    ax=sc.pl.umap(atlas, show=False )
    sc.pl.umap(atlas[(atlas.obs['celltype.l2']=='gdT') | (atlas.obs['celltype.l2']=='MAIT') | 
                     (atlas.obs['celltype.l2']=='dnT') | (atlas.obs['celltype.l2']=='Platelet')], color='celltype.l2', ax=ax)



.. image:: output_17_0.png


‘Other T’ cluster is composed by double negative T cells, gamma delta T
cells and MAIT cells. ‘Other’ cluster is mainly composed by platelets
and for this reason has been renamed ‘Platelet’.

.. code:: ipython3

    atlas.obs['Cell type']=atlas.obs['celltype.l1']

.. code:: ipython3

    # to rename clusters
    atlas.obs['Cell type']=atlas.obs['Cell type'].cat.rename_categories(['B', 'CD4 T', 'CD8 T', 'DC', 'Mono', 'NK', 'Platelet', 'other T'])
    atlas.uns['Cell type_colors']=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f']

We performed **differential expression analysis** (**DEA**) on coarser
resoluted clusters and we selected as DEGs genes having at least **1.5
log2FC**, with minimal **mean of expression 0.25**, **z score 5** and at
least **expressed in 40% of cells** within the cluster in order to
obtain shorter but **more specific gene lists** than a usual DEA.

.. code:: ipython3

    # to read the gmt and create the dictionary of signatures
    df=pd.read_csv('./data/DEGs.gmt', sep='\t', header=None).transpose()
    df=df.rename(columns=df.iloc[0]).drop(df.index[0])
    gmt={}
    for i in df.columns:
        gmt[i]=df[i].dropna().values.tolist()

.. code:: ipython3

    gmt.keys()




.. parsed-literal::

    dict_keys(['B', 'CD4 T', 'CD8 T', 'DC', 'Mono', 'NK', 'Platelet', 'other T'])



.. code:: ipython3

    for i in gmt.keys():
        print(i + ' signature has '+ str(len(gmt[i])) +' genes')


.. parsed-literal::

    B signature has 112 genes
    CD4 T signature has 36 genes
    CD8 T signature has 12 genes
    DC signature has 178 genes
    Mono signature has 712 genes
    NK signature has 102 genes
    Platelet signature has 125 genes
    other T signature has 30 genes


We then assessed the overlap among lists and, **despite the more
stringent DEA** , we found that **CD8 T and CD4 T cells** signatures
show a similarity that is remarkably higher than similarities among all
the other signatures (58.3% of DEGs shared with CD4 T). Furthermore we
found that CD8 T list has similarity with other T list (41% of DEGs),
and that also other T and NK lists are very similar (56%). The authors
themselves claimed that those **populations are difficult to be
effectively discriminated by scRNA-seq alone**, in particular CD8 T an
CD4 T cells. Citing them *“We found that for CD8+ T cells, the most
similar RNA neighbors often reflected a mix of CD8+ and CD4+ T cells (in
the RNA KNN graph, there are a total of 944 incorrect edges that connect
CD8+ to CD4+ T cells). By contrast, protein neighbors were predominantly
correctly identified as CD8+ T cells (in the protein KNN graph, 12
CD8+/CD4+ edges were identified)”*
`[1] <https://www.sciencedirect.com/science/article/pii/S0092867421005833>`__.
For this reason **we can’t consider those signatures completely
specific** and so **we don’t expect to obtain an ideal classification
for those clusters**.

.. code:: ipython3

    similarity={}
    for i in gmt.keys():
        values=[]
        for j in gmt.keys():
            values.append(len(np.intersect1d(gmt[i], gmt[j]))/len(np.union1d(gmt[i], gmt[j])))
        similarity[i]=values
        

.. code:: ipython3

    df=pd.DataFrame(similarity)
    df.index= df.columns
    df




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>B</th>
          <th>CD4 T</th>
          <th>CD8 T</th>
          <th>DC</th>
          <th>Mono</th>
          <th>NK</th>
          <th>Platelet</th>
          <th>other T</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>B</th>
          <td>1.000000</td>
          <td>0.006803</td>
          <td>0.000000</td>
          <td>0.094340</td>
          <td>0.018541</td>
          <td>0.004695</td>
          <td>0.008511</td>
          <td>0.000000</td>
        </tr>
        <tr>
          <th>CD4 T</th>
          <td>0.006803</td>
          <td>1.000000</td>
          <td>0.170732</td>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>0.100000</td>
        </tr>
        <tr>
          <th>CD8 T</th>
          <td>0.000000</td>
          <td>0.170732</td>
          <td>1.000000</td>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>0.017857</td>
          <td>0.007353</td>
          <td>0.135135</td>
        </tr>
        <tr>
          <th>DC</th>
          <td>0.094340</td>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>1.000000</td>
          <td>0.089351</td>
          <td>0.003584</td>
          <td>0.016779</td>
          <td>0.000000</td>
        </tr>
        <tr>
          <th>Mono</th>
          <td>0.018541</td>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>0.089351</td>
          <td>1.000000</td>
          <td>0.002463</td>
          <td>0.026994</td>
          <td>0.000000</td>
        </tr>
        <tr>
          <th>NK</th>
          <td>0.004695</td>
          <td>0.000000</td>
          <td>0.017857</td>
          <td>0.003584</td>
          <td>0.002463</td>
          <td>1.000000</td>
          <td>0.017937</td>
          <td>0.147826</td>
        </tr>
        <tr>
          <th>Platelet</th>
          <td>0.008511</td>
          <td>0.000000</td>
          <td>0.007353</td>
          <td>0.016779</td>
          <td>0.026994</td>
          <td>0.017937</td>
          <td>1.000000</td>
          <td>0.006494</td>
        </tr>
        <tr>
          <th>other T</th>
          <td>0.000000</td>
          <td>0.100000</td>
          <td>0.135135</td>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>0.147826</td>
          <td>0.006494</td>
          <td>1.000000</td>
        </tr>
      </tbody>
    </table>
    </div>



Since **signature refinement is not the intent** of this method and of
this tutorial, and **it should be done upstream** the
annotation/classification step we proceeded using the above described
signatures to show the usages of the proposed functions, and to report
the automatic annotation performances.

Signature score
---------------

signature_score function is **based on “gene signature score”**
calculation method shown in Della Chiara, Gervasoni, Fakiola, Godano et
al. 2021 `[2] <https://www.nature.com/articles/s41467-021-22544-y>`__.
Given a collection of gene signatures, this function, for each
signature, **computes a score for each cell**, **which depends on the
proportion of genes in the cells also found in the signature and their
expression. In this way it is possible to**\ summarize the expression of
a whole gene signature in a single value for each cell**, enabling
researchers to easily study its distribution in the dataset.

To be more clear, the gene signature score was obtained in the following
way:

-  given a cell C defined as a vector of gene expression values
   :math:`[{g}_{i},\ldots ,{g}_{C}]` and a geneset
   :math:`{\bf{G}}=\{{g}_{1},\ldots ,{g}_{G}\}`

-  a coexpression score is calculated as:

:math:`coexpression\_{score}=\frac{{\sum }_{g\in {\bf{G}}}[{\bf{C}}g \,> \, 0]}{|{\bf{G}}|}`

-  an expression score is defined as:

:math:`expression\_{score}=\frac{{\sum }_{g\in {\bf{G}}}{\bf{C}}g}{\sum {\bf{C}}}`

-  the two scores are then combined to yeld the gene signature score:

:math:`gene\_{signature}\_{score}=coexpression\_{score}* expression\_{score}`

Raw score
~~~~~~~~~

The raw score is the very same score described in the above mentioned
paper, it’s the **default score_mode** in signature_score function.

.. code:: ipython3

    investigate.signature_score(data=atlas, signatures_dict=gmt, score_mode='raw')


.. parsed-literal::

    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing raw signature scores ...
    
    "B" added in Anndata.obs
    "CD4 T" added in Anndata.obs
    "CD8 T" added in Anndata.obs
    "DC" added in Anndata.obs
    "Mono" added in Anndata.obs
    "NK" added in Anndata.obs
    "Platelet" added in Anndata.obs
    "other T" added in Anndata.obs


**Signature scores are stored by default in AnnData.obs**, adding a
column for each signature named accordingly to the signature name.

.. code:: ipython3

    gmt.keys()




.. parsed-literal::

    dict_keys(['B', 'CD4 T', 'CD8 T', 'DC', 'Mono', 'NK', 'Platelet', 'other T'])



.. code:: ipython3

    atlas.obs[gmt.keys()]




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>B</th>
          <th>CD4 T</th>
          <th>CD8 T</th>
          <th>DC</th>
          <th>Mono</th>
          <th>NK</th>
          <th>Platelet</th>
          <th>other T</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>L1_AAACCCAAGAAACTCA</th>
          <td>0.003411</td>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>0.024345</td>
          <td>0.124619</td>
          <td>0.001017</td>
          <td>0.007925</td>
          <td>0.000000</td>
        </tr>
        <tr>
          <th>L1_AAACCCAAGACATACA</th>
          <td>0.000930</td>
          <td>0.015989</td>
          <td>0.004350</td>
          <td>0.001129</td>
          <td>0.006057</td>
          <td>0.003222</td>
          <td>0.003798</td>
          <td>0.002663</td>
        </tr>
        <tr>
          <th>L1_AAACCCACAACTGGTT</th>
          <td>0.001028</td>
          <td>0.011516</td>
          <td>0.005799</td>
          <td>0.001441</td>
          <td>0.004820</td>
          <td>0.001884</td>
          <td>0.003972</td>
          <td>0.001394</td>
        </tr>
        <tr>
          <th>L1_AAACCCACACGTACTA</th>
          <td>0.000614</td>
          <td>0.000883</td>
          <td>0.001335</td>
          <td>0.001338</td>
          <td>0.009335</td>
          <td>0.039232</td>
          <td>0.005549</td>
          <td>0.012063</td>
        </tr>
        <tr>
          <th>L1_AAACCCACAGCATACT</th>
          <td>0.000642</td>
          <td>0.008984</td>
          <td>0.006706</td>
          <td>0.000749</td>
          <td>0.006116</td>
          <td>0.002614</td>
          <td>0.004139</td>
          <td>0.001706</td>
        </tr>
        <tr>
          <th>...</th>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
        </tr>
        <tr>
          <th>E2L8_TTTGTTGGTCGTGATT</th>
          <td>0.001091</td>
          <td>0.014318</td>
          <td>0.005315</td>
          <td>0.001573</td>
          <td>0.010515</td>
          <td>0.003647</td>
          <td>0.004036</td>
          <td>0.002721</td>
        </tr>
        <tr>
          <th>E2L8_TTTGTTGGTGTGCCTG</th>
          <td>0.004196</td>
          <td>0.000131</td>
          <td>0.000030</td>
          <td>0.014995</td>
          <td>0.160756</td>
          <td>0.001527</td>
          <td>0.011290</td>
          <td>0.000234</td>
        </tr>
        <tr>
          <th>E2L8_TTTGTTGGTTAGTTCG</th>
          <td>0.036279</td>
          <td>0.000930</td>
          <td>0.000020</td>
          <td>0.011031</td>
          <td>0.024279</td>
          <td>0.001022</td>
          <td>0.005959</td>
          <td>0.000122</td>
        </tr>
        <tr>
          <th>E2L8_TTTGTTGGTTGGCTAT</th>
          <td>0.004657</td>
          <td>0.000144</td>
          <td>0.000017</td>
          <td>0.025606</td>
          <td>0.124834</td>
          <td>0.003452</td>
          <td>0.007623</td>
          <td>0.000107</td>
        </tr>
        <tr>
          <th>E2L8_TTTGTTGTCTCATGGA</th>
          <td>0.003356</td>
          <td>0.000224</td>
          <td>0.000075</td>
          <td>0.020351</td>
          <td>0.129028</td>
          <td>0.001090</td>
          <td>0.009235</td>
          <td>0.000067</td>
        </tr>
      </tbody>
    </table>
    <p>161764 rows × 8 columns</p>
    </div>



Signature scores **can be directly returned as an array** by specifying
return_array=True.

.. code:: ipython3

    investigate.signature_score(data=atlas, signatures_dict=gmt, score_mode='raw', return_array=True)




.. parsed-literal::

    array([[3.41068950e-03, 0.00000000e+00, 0.00000000e+00, ...,
            1.01658321e-03, 7.92513018e-03, 0.00000000e+00],
           [9.29986948e-04, 1.59894576e-02, 4.35036247e-03, ...,
            3.22222079e-03, 3.79808812e-03, 2.66252008e-03],
           [1.02776627e-03, 1.15163465e-02, 5.79854995e-03, ...,
            1.88396143e-03, 3.97232439e-03, 1.39350175e-03],
           ...,
           [3.62785691e-02, 9.29536044e-04, 1.96797664e-05, ...,
            1.02193278e-03, 5.95940216e-03, 1.22091499e-04],
           [4.65747790e-03, 1.44356714e-04, 1.73228057e-05, ...,
            3.45177062e-03, 7.62307498e-03, 1.07469127e-04],
           [3.35584050e-03, 2.23543140e-04, 7.45143799e-05, ...,
            1.08972585e-03, 9.23456389e-03, 6.70629419e-05]])



Scaled score
~~~~~~~~~~~~

Scaled score is the **raw score divided by max score value** for that
given signature, operation which rescales the values from 0 to 1. Scaled
scores of **different signatures**, with **different length**, can thus
be **directly compared**. To compute the ‘scaled’ score score_mode must
be set as ‘scaled’.

.. code:: ipython3

    investigate.signature_score(data=atlas, signatures_dict=gmt, score_mode='scaled')


.. parsed-literal::

    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "B" added in Anndata.obs
    "CD4 T" added in Anndata.obs
    "CD8 T" added in Anndata.obs
    "DC" added in Anndata.obs
    "Mono" added in Anndata.obs
    "NK" added in Anndata.obs
    "Platelet" added in Anndata.obs
    "other T" added in Anndata.obs


.. code:: ipython3

    sc.pl.umap(atlas, color='Cell type')



.. image:: output_43_0.png


By inspecting the score values, for all the signatures, **the highest
values are found in the proper cluster**, indicating the sensitivity of
the signatures and the capablity of the signature score to represent the
expression of the whole gene lists. **CD4 T and CD8 T scores**, as
expected, **show an overlap reflecting their similarity**. In particular
**both** signatures are **highly expressed in CD8 naive subcluster**.

.. code:: ipython3

    sc.pl.umap(atlas, color=gmt.keys(), color_map='Reds')



.. image:: output_45_0.png


.. code:: ipython3

    ax=sc.pl.umap(atlas, show=False )
    sc.pl.umap(atlas[(atlas.obs['celltype.l2']=='CD8 Naive')], color='celltype.l2', ax=ax)



.. image:: output_46_0.png


Inspecting the violin plots showing the **distribution of score
values**, as expected, it seems that **there is a cluster in which
values are higher than all the others** for each signature.

.. code:: ipython3

    sc.pl.violin(atlas, keys=gmt.keys(), groupby='Cell type')



.. image:: output_48_0.png


To better viusualize those distributions, we exploited
**grouped_distributions**. By selecting AnnData.obs columns containing
**signature scores**, this function plots **a heatmap showing the
medians of their values in cell groups** (each of the above shown violin
plot information is condensed in a heatmap column) and it prints **a
statistical report**. **For each cell group**, a two-sided **Wilcoxon
test** is perfomed to evaluate if the distribution with the highest
median is different from the others. **For each signature**, a two-sided
**Mann-Whitney U test** is performed to evaluate if the distribution in
the cell group having the highest median is different from the other
groups distributions.

.. code:: ipython3

    report.grouped_distributions(atlas, groups_obs='Cell type', columns_obs=gmt.keys(), scale_medians='column-wise', cmap='Blues')


.. parsed-literal::

    Performing Wilcoxon test on each cell group ...
    For each cell group there is a distribution significantly higher than the others (p<0.01)
    
    Performing Mann-Whitney U test on each selected AnnData.obs column ...
    For each distribution, there is only a cell group in which values are higher with respect to all the other groups  (p<0.01)



.. image:: output_50_1.png


The statistical tests confirmed that the **visible differences in
signature score distributions are significant**, indicating that scaled
signature score are consistent with authors annotation.

Test dataset
------------

In order **to evaluate both the consistency** of our method **and the
performances of classification**,\ **we used** the PMBC atlas **DEGs to
automatically annotate** the well characterised
`PBMC3K <https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc3k.html>`__
from Satija et al. 2015
`[3] <https://www.nature.com/articles/nbt.3192>`__. This dataset was
annotated relying on clustering and marker genes expression inspection
and it is widely used as reference in the scientific community. **We
classified** this dataset **independently from the already present
annotation**, whose **cell labels were used as ground truth** to
evaluate our classification perfomances with different modalities.

.. code:: ipython3

    pbmc3k = sc.read('./data/pbmc3k.h5ad')

For the classification of the test dataset **we excluded ‘other T’
signature** since this population was not annotated by the authors. **We
also renamed and merged some clusters** in order to make easier the
comparison and the visualization of results. In particular,‘CD14+
Monocytes’ and ‘FCGR3A+ Monocytes’ clusters were merged into ‘Mono’.

.. code:: ipython3

    gmtc=gmt.copy()
    del gmtc['other T'] # not annotated in test datasets

.. code:: ipython3

    sc.pl.umap(pbmc3k, color=['louvain','Cell type'], wspace=0.5)



.. image:: output_57_0.png


.. code:: ipython3

    investigate.signature_score(data=pbmc3k, signatures_dict=gmtc, score_mode='scaled')


.. parsed-literal::

    Checking for genes not in AnnData.raw.var_names ...
    
    14/112 of "B" signature genes were removed since they are not in AnnData.raw.var_names
    3/36 of "CD4 T" signature genes were removed since they are not in AnnData.raw.var_names
    2/12 of "CD8 T" signature genes were removed since they are not in AnnData.raw.var_names
    5/178 of "DC" signature genes were removed since they are not in AnnData.raw.var_names
    25/712 of "Mono" signature genes were removed since they are not in AnnData.raw.var_names
    3/102 of "NK" signature genes were removed since they are not in AnnData.raw.var_names
    9/125 of "Platelet" signature genes were removed since they are not in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "B" added in Anndata.obs
    "CD4 T" added in Anndata.obs
    "CD8 T" added in Anndata.obs
    "DC" added in Anndata.obs
    "Mono" added in Anndata.obs
    "NK" added in Anndata.obs
    "Platelet" added in Anndata.obs


.. code:: ipython3

    scaled_scores_pbmc3k=['CD4 T', 'B', 'CD8 T', 'NK', 'Mono', 'DC', 'Platelet']

.. code:: ipython3

    report.grouped_distributions(pbmc3k, groups_obs='Cell type', columns_obs=scaled_scores_pbmc3k, scale_medians='column-wise', cmap='Blues')


.. parsed-literal::

    Performing Wilcoxon test on each cell group ...
    For each cell group there is a distribution significantly higher than the others (p<0.01)
    
    Performing Mann-Whitney U test on each selected AnnData.obs column ...
    For each distribution, there is only a cell group in which values are higher with respect to all the other groups  (p<0.01)



.. image:: output_60_1.png


**Also for PBMC3K**, for each signature, **there is a cluster in which
scores are significantly higher than all the others**. This confirmed
the consistency of the of signatures across datasets and suggested that
the **scaled score could be per se sufficient to help researchers in an
eventual annotation**, permitting to **skip the one-by-one evaluation**
of DEGs reported in literature as marker genes.

Signature-based classification
------------------------------

To classify both PBMC atlas and test datasets we used
**signature_based_classification**. **Two** main classification
**modalities** have been implemented: a **fast classification mode**, in
which scaled scores are directly computed and compared, and a **FC
score-based mode** that, relying on the comparison between raw signature
scores and randomic signature scores, can provide a more confident
classification at the cost of computation time.

Fast classification
~~~~~~~~~~~~~~~~~~~

Fast classification is performed by **assigning to each cell the label
of the signature with the max scaled score value**. Being based on
matrices and vectors operations this computation is **very fast** (the
161764 cells of the PBMC atlas were classified with the high-performance
computing server infrastructure of our institute in nearby 22s).

**To counteract the transcriptional similarity** between CD4 T and CD8 T
cells **we used the population-defining key genes expression as negative
markers** (CD8A and CD8B for CD4 T cells; CD4 for CD8 T cells).

.. code:: ipython3

    neg={'CD8 T':['CD4'], 'CD4 T':['CD8A', 'CD8B']}

By assigning neg dictionary to negative_markers paramaters **a scaled
score is computed** for both CD8 T and CD4 T negative markers,
**inverted** (score= 1-score) and **multiplied by corresponding
signature values**.

.. code:: ipython3

    investigate.signature_based_classification(data=atlas, signatures_dict=gmt, negative_markers=neg,
                                               fast_mode=True, obs_name='Prediction fast mode')


.. parsed-literal::

    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "CD8 T_negative" added in Anndata.obs
    "CD4 T_negative" added in Anndata.obs
    
    Classification labels added in AnnData.obs["Prediction fast mode"]
    
    Runtime of the process is 24.51 s 




.. parsed-literal::

    'Fast classification complete!'



.. code:: ipython3

    atlas.uns['Prediction fast mode_colors']=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',
           '#e377c2', '#7f7f7f']

By inspecting and comparing the ground truth and the predicted labels is
evident that, as expected, **the vast majority of the cells was
correctly classified**. The major difference, given the CD4/CD8
trancriptional overlap clearly reported in the atlas study, is found in
CD8 T cluster, specifically in the **CD8 Naive subcluster** which **is
partially classified as CD4**.

.. code:: ipython3

    sc.pl.umap(atlas, color=['Cell type','Prediction fast mode'],  palette=None,  wspace=0.5)


.. parsed-literal::

    ... storing 'Prediction fast mode' as categorical



.. image:: output_72_1.png


However **in each cluster the highest percentage of cell composition is
given by the expected cell type**, which is a lot higher than the second
most high.

.. code:: ipython3

    report.group_composition(atlas, classification_obs='Prediction fast mode', groups_obs='Cell type',
                      columns_order=['B', 'CD4 T', 'CD8 T', 'DC', 'Mono', 'NK', 'Platelet', 'other T'])



.. image:: output_74_0.png


With the very same procedure **we classified the PBMC3K dataset** using
the **atlas derived signature**.

.. code:: ipython3

    investigate.signature_based_classification(data=pbmc3k, signatures_dict=gmtc, negative_markers=neg, 
                                               fast_mode=True, obs_name='Prediction fast mode')


.. parsed-literal::

    14/112 of "B" signature genes were removed since they are not in AnnData.raw.var_names
    3/36 of "CD4 T" signature genes were removed since they are not in AnnData.raw.var_names
    2/12 of "CD8 T" signature genes were removed since they are not in AnnData.raw.var_names
    5/178 of "DC" signature genes were removed since they are not in AnnData.raw.var_names
    25/712 of "Mono" signature genes were removed since they are not in AnnData.raw.var_names
    3/102 of "NK" signature genes were removed since they are not in AnnData.raw.var_names
    9/125 of "Platelet" signature genes were removed since they are not in AnnData.raw.var_names
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "CD8 T_negative" added in Anndata.obs
    "CD4 T_negative" added in Anndata.obs
    
    Classification labels added in AnnData.obs["Prediction fast mode"]
    
    Runtime of the process is 0.32 s 




.. parsed-literal::

    'Fast classification complete!'



.. code:: ipython3

    pbmc3k.uns['Prediction fast mode_colors']=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2']

.. code:: ipython3

    sc.pl.umap(pbmc3k, color=['Cell type','Prediction fast mode'],  palette=None,  wspace=0.5, s=70)


.. parsed-literal::

    ... storing 'Prediction fast mode' as categorical



.. image:: output_78_1.png


An **analogue situation was found also in PBMC3K**, where again most of
the cells have been correctly assigned, indicating that **PBMC atlas
signatures can be used to classify other datasets**.

.. code:: ipython3

    report.group_composition(pbmc3k, classification_obs='Prediction fast mode', groups_obs='Cell type',
                      columns_order=['CD4 T', 'B', 'CD8 T', 'NK', 'Mono', 'DC', 'Platelet'])



.. image:: output_80_0.png


**We checked the expression of CD4, CD8A and CD8B genes** across groups
defined both by **ground truth clustering-driven annotation and
CIA-driven annotation**. Surprisingly, relying on **their annotation**,
we found that the **percentage of CD8A and CD8B expressing cell** is
**comparable** with the **percentage of CD4 T expressing cells of CD4 T
cluster**.

.. code:: ipython3

    sc.pl.dotplot(pbmc3k, var_names=['CD4', 'CD8A', 'CD8B'], groupby='Cell type')



.. image:: output_82_0.png


While with **our annotation those percentages were consinstently
reduced**, suggesting that our clustering-independent annotation **is
more precise while discriminating CD4 T / CD8 T cells** than
clustering-driven one reported in Satija et al. 2015
`[3] <https://www.nature.com/articles/nbt.3192>`__.

.. code:: ipython3

    sc.pl.dotplot(pbmc3k, var_names=['CD4', 'CD8A', 'CD8B'], groupby='Prediction fast mode')



.. image:: output_84_0.png


FC score-based classification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FC score-based classification is performed by **looking for the max Fold
Change score value for each cell instead of scaled score one**. FC score
is computed by dividing the raw signatue score by the median of raw
scores of a given number (n_iter) of **randomic signatures**. To
generate randomic signatures, all genes of the dataset are ranked by
their mean expression and are assigned to a given bin, and **for each
signature gene a randomic gene of the same expression bin is taken**.

Standard mode
^^^^^^^^^^^^^

Standard mode is performed with default parameters: all the **FC scores
lower than 1 (randomic score < signature score) are turned into 0**, and
if a cell has a FC score equal to 0 for all the signature it will not be
assigned. This approach is slower with respect to fast mode and it could
be affected by a **decrease of performances due to unassigned cells, but
in this way the classified cells are labelled with an higher
confidence** and cells with low FCs (e.g. not fully differentiated) are
not forced to be classified. To speed-up the process **it’s possible to
parallelize** the computations allocating jobs to a given number of
processors (n_proc). By setting **new_score=‘FC’**, **raw scores in
AnnData.obs can be replaced by FC values**.

With the same approach described for fast classification we classified
both PBMC atlas and PBMC3K with the standard mode, adjusting again the
CD4 T / CD8 T labelling with a second round of focused classification.

.. code:: ipython3

    investigate.signature_based_classification(data=atlas, signatures_dict=gmt, n_iter=500, n_proc=32, negative_markers=neg,
                                       obs_name='Prediction standard mode', new_score='FC' , FC_threshold= 1, n_bins=25)


.. parsed-literal::

    
    WARNING: Dear, pay attention!
    If you use a number of bins higher or equal to  15 , you may not have enough random genes in a bin. 
    So we suggest you to reduce 'n_bins'.
    
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing raw signature scores ...
    
    "B" added in Anndata.obs
    "CD4 T" added in Anndata.obs
    "CD8 T" added in Anndata.obs
    "DC" added in Anndata.obs
    "Mono" added in Anndata.obs
    "NK" added in Anndata.obs
    "Platelet" added in Anndata.obs
    "other T" added in Anndata.obs
    
    raw scores are being replaced by Fold Change signature scores ...
    
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "CD8 T_negative" added in Anndata.obs
    "CD4 T_negative" added in Anndata.obs
    
    Classification labels added in AnnData.obs["Prediction standard mode"]
    
    Results have been stored in AnnData.uns["signature_based_classification"]
    
    Runtime of the process is 85.85 min with 32 cores


.. code:: ipython3

    atlas.uns['Prediction standard mode_colors']= ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#bcbd22','#7f7f7f']

.. code:: ipython3

    sc.pl.umap(atlas,color=['Cell type', 'Prediction standard mode'])


.. parsed-literal::

    ... storing 'Prediction standard mode' as categorical



.. image:: output_92_1.png


Beside the possibility to substitute raw score values in AnnData.obs, by
default **both FC scores and filtered FC scores are stored in
AnnData.uns**.

.. code:: ipython3

    df=atlas.uns["signature_based_classification"]
    df=df.iloc[:, 8:16]
    df.index=atlas.obs.index
    atlas.obs[df.columns]=df

.. code:: ipython3

    filtered_FC_atlas=['B_filtered_FC','CD4 T_filtered_FC','CD8 T_filtered_FC','DC_filtered_FC',
                       'Mono_filtered_FC','NK_filtered_FC','Platelet_filtered_FC','other T_filtered_FC']

By inspecting the distributions of **filtered FC scores**, as expected,
it is even more evident that **each signature is preferentially
expressed by one cell group**.

.. code:: ipython3

    report.grouped_distributions(atlas, columns_obs=filtered_FC_atlas, groups_obs='Cell type', cmap='Blues', scale_medians='column-wise')


.. parsed-literal::

    Performing Wilcoxon test on each cell group ...
    For each cell group there is a distribution significantly higher than the others (p<0.01)
    
    Performing Mann-Whitney U test on each selected AnnData.obs column ...
    For each distribution, there is only a cell group in which values are higher with respect to all the other groups  (p<0.01)



.. image:: output_97_1.png


Indeed, the majority of each cell group has been **correctly
classified**.

.. code:: ipython3

    report.group_composition(atlas, classification_obs='Prediction standard mode', groups_obs='Cell type',
                      columns_order=['B', 'CD4 T', 'CD8 T', 'DC', 'Mono', 'NK', 'Platelet', 'other T', 'Unassigned'])



.. image:: output_99_0.png


The same evaluations were done for PBMC3K dataset.

.. code:: ipython3

    investigate.signature_based_classification(data=pbmc3k, signatures_dict=gmtc, negative_markers=neg,
                        n_iter=500, n_proc=32,  new_score='FC', obs_name='Prediction standard mode', FC_threshold= 1, n_bins=25)


.. parsed-literal::

    
    WARNING: Dear, pay attention!
    If you use a number of bins higher or equal to  10 , you may not have enough random genes in a bin. 
    So we suggest you to reduce 'n_bins'.
    
    Checking for genes not in AnnData.raw.var_names ...
    
    14/112 of "B" signature genes were removed since they are not in AnnData.raw.var_names
    3/36 of "CD4 T" signature genes were removed since they are not in AnnData.raw.var_names
    2/12 of "CD8 T" signature genes were removed since they are not in AnnData.raw.var_names
    5/178 of "DC" signature genes were removed since they are not in AnnData.raw.var_names
    25/712 of "Mono" signature genes were removed since they are not in AnnData.raw.var_names
    3/102 of "NK" signature genes were removed since they are not in AnnData.raw.var_names
    9/125 of "Platelet" signature genes were removed since they are not in AnnData.raw.var_names
    
    Computing raw signature scores ...
    
    "B" added in Anndata.obs
    "CD4 T" added in Anndata.obs
    "CD8 T" added in Anndata.obs
    "DC" added in Anndata.obs
    "Mono" added in Anndata.obs
    "NK" added in Anndata.obs
    "Platelet" added in Anndata.obs
    
    raw scores are being replaced by Fold Change signature scores ...
    
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "CD8 T_negative" added in Anndata.obs
    "CD4 T_negative" added in Anndata.obs
    
    Classification labels added in AnnData.obs["Prediction standard mode"]
    
    Results have been stored in AnnData.uns["signature_based_classification"]
    
    Runtime of the process is 0.81 min with 32 cores


.. code:: ipython3

    pbmc3k.uns['Prediction standard mode_colors']=['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#bcbd22']

.. code:: ipython3

    sc.pl.umap(pbmc3k,color=['Cell type', 'Prediction standard mode'])


.. parsed-literal::

    ... storing 'Prediction standard mode' as categorical



.. image:: output_103_1.png


.. code:: ipython3

    df=pbmc3k.uns['signature_based_classification']
    df=df.iloc[:, 7:14]
    df.index=pbmc3k.obs.index
    pbmc3k.obs[df.columns]=df

.. code:: ipython3

    filtered_FC_pbmc3k=['CD4 T_filtered_FC','B_filtered_FC','CD8 T_filtered_FC','NK_filtered_FC',
                        'Mono_filtered_FC','DC_filtered_FC','Platelet_filtered_FC']

.. code:: ipython3

    report.grouped_distributions(pbmc3k, columns_obs=filtered_FC_pbmc3k, groups_obs='Cell type', cmap='Blues', scale_medians='column-wise')


.. parsed-literal::

    Performing Wilcoxon test on each cell group ...
    For each cell group there is a distribution significantly higher than the others (p<0.01)
    
    Performing Mann-Whitney U test on each selected AnnData.obs column ...
    For each distribution, there is only a cell group in which values are higher with respect to all the other groups  (p<0.01)



.. image:: output_106_1.png


.. code:: ipython3

    report.group_composition(pbmc3k, classification_obs='Prediction standard mode', groups_obs='Cell type',
                      columns_order=['CD4 T', 'B', 'CD8 T', 'NK', 'Mono', 'DC', 'Platelet'])



.. image:: output_107_0.png


**No major differences have been detected** between fast and standard
classification in both datasets, suggesting a per se validity of scaled
score to perform a fast explorative cell type prediction.

Quantile-based filtering mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Quantile based filter adds another layer of stringency** to the
classification by acting on FC distributions. By setting q equal to a
number from 0 to 1, all the FC score values below that given quantile
are set 0. In this way **only the highest values of FC are mainteined
and so only the most signature-expressing cells will be classified**.
This could be very useful in case of bimodal distribution of score
values or when a signature is moderately expressed in all the clusters.

.. code:: ipython3

    investigate.signature_based_classification(data=atlas, signatures_dict=gmt, negative_markers=neg,
                        n_iter=500, n_proc=32, obs_name='Prediction q', q=0.50, n_bins=25)


.. parsed-literal::

    
    WARNING: Dear, pay attention!
    If you use a number of bins higher or equal to  15 , you may not have enough random genes in a bin. 
    So we suggest you to reduce 'n_bins'.
    
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing raw signature scores ...
    
    "B" added in Anndata.obs
    "CD4 T" added in Anndata.obs
    "CD8 T" added in Anndata.obs
    "DC" added in Anndata.obs
    "Mono" added in Anndata.obs
    "NK" added in Anndata.obs
    "Platelet" added in Anndata.obs
    "other T" added in Anndata.obs
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "CD8 T_negative" added in Anndata.obs
    "CD4 T_negative" added in Anndata.obs
    
    Classification labels added in AnnData.obs["Prediction q"]
    
    Results have been stored in AnnData.uns["signature_based_classification"]
    
    Runtime of the process is 84.39 min with 32 cores


.. code:: ipython3

    atlas.uns['Prediction q_colors']=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', 
                                      '#bcbd22', '#7f7f7f']

.. code:: ipython3

    sc.pl.umap(atlas,color=['Cell type', 'Prediction q'])


.. parsed-literal::

    ... storing 'Prediction q' as categorical



.. image:: output_113_1.png


.. code:: ipython3

    df=atlas.uns["signature_based_classification"]
    df=df.iloc[:, 8:16]
    df.index=atlas.obs.index
    atlas.obs[df.columns]=df
    
    report.grouped_distributions(atlas, columns_obs=filtered_FC_atlas, groups_obs='Cell type', cmap='Blues', scale_medians='column-wise')


.. parsed-literal::

    Performing Wilcoxon test on each cell group ...
    For each cell group there is a distribution significantly higher than the others (p<0.01)
    
    Performing Mann-Whitney U test on each selected AnnData.obs column ...
    For each distribution, there is only a cell group in which values are higher with respect to all the other groups  (p<0.01)



.. image:: output_114_1.png


.. code:: ipython3

    report.group_composition(atlas, classification_obs='Prediction q', groups_obs='Cell type',
                      columns_order=['B', 'CD4 T', 'CD8 T', 'DC', 'Mono', 'NK', 'Platelet', 'other T', 'Unassigned'])



.. image:: output_115_0.png


.. code:: ipython3

    investigate.signature_based_classification(data=pbmc3k, signatures_dict=gmtc, negative_markers=neg,
                        n_iter=500, n_proc=32, obs_name='Prediction q', q=0.50, n_bins=25)


.. parsed-literal::

    
    WARNING: Dear, pay attention!
    If you use a number of bins higher or equal to  10 , you may not have enough random genes in a bin. 
    So we suggest you to reduce 'n_bins'.
    
    Checking for genes not in AnnData.raw.var_names ...
    
    14/112 of "B" signature genes were removed since they are not in AnnData.raw.var_names
    3/36 of "CD4 T" signature genes were removed since they are not in AnnData.raw.var_names
    2/12 of "CD8 T" signature genes were removed since they are not in AnnData.raw.var_names
    5/178 of "DC" signature genes were removed since they are not in AnnData.raw.var_names
    25/712 of "Mono" signature genes were removed since they are not in AnnData.raw.var_names
    3/102 of "NK" signature genes were removed since they are not in AnnData.raw.var_names
    9/125 of "Platelet" signature genes were removed since they are not in AnnData.raw.var_names
    
    Computing raw signature scores ...
    
    "B" added in Anndata.obs
    "CD4 T" added in Anndata.obs
    "CD8 T" added in Anndata.obs
    "DC" added in Anndata.obs
    "Mono" added in Anndata.obs
    "NK" added in Anndata.obs
    "Platelet" added in Anndata.obs
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "CD8 T_negative" added in Anndata.obs
    "CD4 T_negative" added in Anndata.obs
    
    Classification labels added in AnnData.obs["Prediction q"]
    
    Results have been stored in AnnData.uns["signature_based_classification"]
    
    Runtime of the process is 0.79 min with 32 cores


.. code:: ipython3

    pbmc3k.uns['Prediction q_colors']=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#bcbd22']

.. code:: ipython3

    sc.pl.umap(pbmc3k,color=['Cell type', 'Prediction q'])


.. parsed-literal::

    ... storing 'Prediction q' as categorical



.. image:: output_118_1.png


.. code:: ipython3

    df=pbmc3k.uns['signature_based_classification']
    df=df.iloc[:, 7:14]
    df.index=pbmc3k.obs.index
    pbmc3k.obs[df.columns]=df
    
    report.grouped_distributions(pbmc3k, columns_obs=filtered_FC_pbmc3k, groups_obs='Cell type', cmap='Blues', scale_medians='column-wise')


.. parsed-literal::

    Performing Wilcoxon test on each cell group ...
    For each cell group there is a distribution significantly higher than the others (p<0.01)
    
    Performing Mann-Whitney U test on each selected AnnData.obs column ...
    For each distribution, there is only a cell group in which values are higher with respect to all the other groups  (p<0.01)



.. image:: output_119_1.png


.. code:: ipython3

    report.group_composition(pbmc3k, classification_obs='Prediction q', groups_obs='Cell type',
                      columns_order=['CD4 T', 'B', 'CD8 T', 'NK', 'Mono', 'DC', 'Platelet'])



.. image:: output_120_0.png


Again, **no major differences have been found**, indicating the
consistency of the signatures. As expected, the clusters with the
highest variability are CD8 T and CD4 T which as mentioned before have
aspecific signatures.

p value-based filtering mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**The most stringent level of classification** is given by p-val mode.
As mentioned before, FC score is obtained by dividing raw signature
scores for the median of scores of n_iter \* randomic signatures. **For
each signature, for each cell, a p-value is calculated by counting how
many times random signature values are higher than gene signature one
(all divided by n_inter)**. If p-value is higher than the set p the FC
score of that cell for that signature will become 0. In this way **only
the significantly signature-expressing cells will be assigned**.

.. code:: ipython3

    investigate.signature_based_classification(data=atlas, signatures_dict=gmt, negative_markers=neg,
                        n_iter=500, n_proc=32, obs_name='Prediction p-val', p=0.05, n_bins=25, new_score='FC')


.. parsed-literal::

    
    WARNING: Dear, pay attention!
    If you use a number of bins higher or equal to  15 , you may not have enough random genes in a bin. 
    So we suggest you to reduce 'n_bins'.
    
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing raw signature scores ...
    
    "B" added in Anndata.obs
    "CD4 T" added in Anndata.obs
    "CD8 T" added in Anndata.obs
    "DC" added in Anndata.obs
    "Mono" added in Anndata.obs
    "NK" added in Anndata.obs
    "Platelet" added in Anndata.obs
    "other T" added in Anndata.obs
    
    raw scores are being replaced by Fold Change signature scores ...
    
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "CD8 T_negative" added in Anndata.obs
    "CD4 T_negative" added in Anndata.obs
    
    Classification labels added in AnnData.obs["Prediction p-val"]
    
    Results have been stored in AnnData.uns["signature_based_classification"]
    
    Runtime of the process is 83.24 min with 32 cores


.. code:: ipython3

    atlas.uns['Prediction p-val_colors']=['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#bcbd22','#7f7f7f']

.. code:: ipython3

    sc.pl.umap(atlas, color=['Cell type','Prediction p-val'], wspace=0.5)


.. parsed-literal::

    ... storing 'Prediction p-val' as categorical



.. image:: output_126_1.png


.. code:: ipython3

    df=atlas.uns["signature_based_classification"]
    df=df.iloc[:, 8:16]
    df.index=atlas.obs.index
    atlas.obs[df.columns]=df
    
    report.grouped_distributions(atlas, columns_obs=filtered_FC_atlas, groups_obs='Cell type', cmap='Blues', scale_medians='column-wise')


.. parsed-literal::

    Performing Wilcoxon test on each cell group ...
    For each cell group there is a distribution significantly higher than the others (p<0.01)
    
    Performing Mann-Whitney U test on each selected AnnData.obs column ...
    For each distribution, there is only a cell group in which values are higher with respect to all the other groups  (p<0.01)



.. image:: output_127_1.png


.. code:: ipython3

    report.group_composition(atlas, classification_obs='Prediction p-val', groups_obs='Cell type',
                      columns_order=['B', 'CD4 T', 'CD8 T', 'DC', 'Mono', 'NK', 'Platelet', 'other T', 'Unassigned'])



.. image:: output_128_0.png


.. code:: ipython3

    investigate.signature_based_classification(data=pbmc3k, signatures_dict=gmtc, negative_markers=neg,
                        n_iter=500, n_proc=32, obs_name='Prediction p-val', p=0.05, n_bins=25, new_score='FC')


.. parsed-literal::

    
    WARNING: Dear, pay attention!
    If you use a number of bins higher or equal to  10 , you may not have enough random genes in a bin. 
    So we suggest you to reduce 'n_bins'.
    
    Checking for genes not in AnnData.raw.var_names ...
    
    14/112 of "B" signature genes were removed since they are not in AnnData.raw.var_names
    3/36 of "CD4 T" signature genes were removed since they are not in AnnData.raw.var_names
    2/12 of "CD8 T" signature genes were removed since they are not in AnnData.raw.var_names
    5/178 of "DC" signature genes were removed since they are not in AnnData.raw.var_names
    25/712 of "Mono" signature genes were removed since they are not in AnnData.raw.var_names
    3/102 of "NK" signature genes were removed since they are not in AnnData.raw.var_names
    9/125 of "Platelet" signature genes were removed since they are not in AnnData.raw.var_names
    
    Computing raw signature scores ...
    
    "B" added in Anndata.obs
    "CD4 T" added in Anndata.obs
    "CD8 T" added in Anndata.obs
    "DC" added in Anndata.obs
    "Mono" added in Anndata.obs
    "NK" added in Anndata.obs
    "Platelet" added in Anndata.obs
    
    raw scores are being replaced by Fold Change signature scores ...
    
    Checking for genes not in AnnData.raw.var_names ...
    
    All signature genes are in AnnData.raw.var_names
    
    Computing scaled signature scores ...
    
    "CD8 T_negative" added in Anndata.obs
    "CD4 T_negative" added in Anndata.obs
    
    Classification labels added in AnnData.obs["Prediction p-val"]
    
    Results have been stored in AnnData.uns["signature_based_classification"]
    
    Runtime of the process is 0.78 min with 32 cores


.. code:: ipython3

    pbmc3k.uns['Prediction p-val_colors']=['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#bcbd22']

.. code:: ipython3

    sc.pl.umap(pbmc3k, color=['Cell type','Prediction p-val'])


.. parsed-literal::

    ... storing 'Prediction p-val' as categorical



.. image:: output_131_1.png


.. code:: ipython3

    df=pbmc3k.uns['signature_based_classification']
    df=df.iloc[:, 7:14]
    df.index=pbmc3k.obs.index
    pbmc3k.obs[df.columns]=df
    
    report.grouped_distributions(pbmc3k, columns_obs=filtered_FC_pbmc3k, groups_obs='Cell type', cmap='Blues', scale_medians='column-wise')


.. parsed-literal::

    Performing Wilcoxon test on each cell group ...
    For each cell group there is a distribution significantly higher than the others (p<0.01)
    
    Performing Mann-Whitney U test on each selected AnnData.obs column ...
    For each distribution, there is only a cell group in which values are higher with respect to all the other groups  (p<0.01)



.. image:: output_132_1.png


.. code:: ipython3

    report.group_composition(pbmc3k, classification_obs='Prediction p-val', groups_obs='Cell type',
                      columns_order=['CD4 T', 'B', 'CD8 T', 'NK', 'Mono', 'DC', 'Platelet', 'Unassigned'])



.. image:: output_133_0.png


Again, **no majour differences were found with the statistically
relevant p-value mode**, suggesting the **consistency of our
classification method**.

Classification performance evaluation
-------------------------------------

To evaluate classification performances both overall and per-cluster we
exploited respectively classification_metrics and
grouped_classification_metrics.

In both functions **cell labels assigned by CIA and the annotation
already present in test datasets are compared** in order to count true
positive (TP), true negative (TN), false positive (FP) and false
negative (FN) cells for each cluster. Only for the overall calculation
the per-cluster counts are summed to obtain the total TN, TP, FN and FP.

Then, again for both functions, the following metriacs are calculated: -
**Sensitivity** (SE)= TP/(TP+FN) - **Specificity** (SP)= TN/(TN+FP) -
**Precision** (PR)= TP/(TP+FP) - **Accuracy** (ACC)=
(TN+TP)/(TN+TP+FN+FP) - **F1-score** (F1)= 2\ *TP/(2*\ TP+FN+FP)

Here, for clarity, we show only the **per cluster classification**
metrics of the statistically relevant **p-value based method** for both
datasets.

.. code:: ipython3

    report.grouped_classification_metrics(atlas, classification_obs='Prediction fast mode',groups_obs='Cell type')




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>SE</th>
          <th>SP</th>
          <th>PR</th>
          <th>ACC</th>
          <th>F1</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>B</th>
          <td>0.986377</td>
          <td>0.999946</td>
          <td>0.999413</td>
          <td>0.998788</td>
          <td>0.992852</td>
        </tr>
        <tr>
          <th>CD4 T</th>
          <td>0.919856</td>
          <td>0.930566</td>
          <td>0.818113</td>
          <td>0.927852</td>
          <td>0.866006</td>
        </tr>
        <tr>
          <th>CD8 T</th>
          <td>0.636303</td>
          <td>0.980924</td>
          <td>0.861746</td>
          <td>0.926665</td>
          <td>0.732061</td>
        </tr>
        <tr>
          <th>DC</th>
          <td>0.980496</td>
          <td>0.994582</td>
          <td>0.804159</td>
          <td>0.994269</td>
          <td>0.883616</td>
        </tr>
        <tr>
          <th>Mono</th>
          <td>0.988309</td>
          <td>0.991841</td>
          <td>0.981360</td>
          <td>0.990771</td>
          <td>0.984822</td>
        </tr>
        <tr>
          <th>NK</th>
          <td>0.955154</td>
          <td>0.987289</td>
          <td>0.907411</td>
          <td>0.983581</td>
          <td>0.930671</td>
        </tr>
        <tr>
          <th>Platelet</th>
          <td>0.524695</td>
          <td>0.999994</td>
          <td>0.999447</td>
          <td>0.989880</td>
          <td>0.688131</td>
        </tr>
        <tr>
          <th>other T</th>
          <td>0.685521</td>
          <td>0.978074</td>
          <td>0.577993</td>
          <td>0.965796</td>
          <td>0.627181</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: ipython3

    report.grouped_classification_metrics(pbmc3k, classification_obs='Prediction p-val',groups_obs='Cell type')




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>SE</th>
          <th>SP</th>
          <th>PR</th>
          <th>ACC</th>
          <th>F1</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>CD4 T</th>
          <td>0.686189</td>
          <td>0.988621</td>
          <td>0.978803</td>
          <td>0.857468</td>
          <td>0.806783</td>
        </tr>
        <tr>
          <th>B</th>
          <td>0.994152</td>
          <td>0.997387</td>
          <td>0.982659</td>
          <td>0.996967</td>
          <td>0.988372</td>
        </tr>
        <tr>
          <th>CD8 T</th>
          <td>0.756329</td>
          <td>0.878984</td>
          <td>0.459615</td>
          <td>0.864291</td>
          <td>0.571770</td>
        </tr>
        <tr>
          <th>NK</th>
          <td>0.974026</td>
          <td>0.975845</td>
          <td>0.714286</td>
          <td>0.975739</td>
          <td>0.824176</td>
        </tr>
        <tr>
          <th>Mono</th>
          <td>0.988889</td>
          <td>0.995020</td>
          <td>0.984202</td>
          <td>0.993556</td>
          <td>0.986540</td>
        </tr>
        <tr>
          <th>DC</th>
          <td>0.891892</td>
          <td>0.998078</td>
          <td>0.868421</td>
          <td>0.996588</td>
          <td>0.880000</td>
        </tr>
        <tr>
          <th>Platelet</th>
          <td>0.933333</td>
          <td>0.993138</td>
          <td>0.437500</td>
          <td>0.992798</td>
          <td>0.595745</td>
        </tr>
      </tbody>
    </table>
    </div>



And here are reported the **overall perfomances for each method**:

.. code:: ipython3

    report.classification_metrics(atlas, 
                           classification_obs=['Prediction fast mode', 'Prediction standard mode', 'Prediction q', 'Prediction p-val'],
                           groups_obs='Cell type')




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>SE</th>
          <th>SP</th>
          <th>PR</th>
          <th>ACC</th>
          <th>F1</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>Prediction fast mode</th>
          <td>0.888801</td>
          <td>0.984114</td>
          <td>0.888801</td>
          <td>0.972200</td>
          <td>0.888801</td>
        </tr>
        <tr>
          <th>Prediction standard mode</th>
          <td>0.861694</td>
          <td>0.980316</td>
          <td>0.862141</td>
          <td>0.965488</td>
          <td>0.861917</td>
        </tr>
        <tr>
          <th>Prediction q</th>
          <td>0.861694</td>
          <td>0.980316</td>
          <td>0.862141</td>
          <td>0.965488</td>
          <td>0.861917</td>
        </tr>
        <tr>
          <th>Prediction p-val</th>
          <td>0.844533</td>
          <td>0.979882</td>
          <td>0.857079</td>
          <td>0.962963</td>
          <td>0.850760</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: ipython3

    report.classification_metrics(pbmc3k, 
                           classification_obs=['Prediction fast mode', 'Prediction standard mode', 'Prediction q', 'Prediction p-val'],
                           groups_obs='Cell type')




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>SE</th>
          <th>SP</th>
          <th>PR</th>
          <th>ACC</th>
          <th>F1</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>Prediction fast mode</th>
          <td>0.890068</td>
          <td>0.981678</td>
          <td>0.890068</td>
          <td>0.968591</td>
          <td>0.890068</td>
        </tr>
        <tr>
          <th>Prediction standard mode</th>
          <td>0.829037</td>
          <td>0.971506</td>
          <td>0.829037</td>
          <td>0.951153</td>
          <td>0.829037</td>
        </tr>
        <tr>
          <th>Prediction q</th>
          <td>0.827900</td>
          <td>0.971633</td>
          <td>0.829472</td>
          <td>0.951099</td>
          <td>0.828685</td>
        </tr>
        <tr>
          <th>Prediction p-val</th>
          <td>0.827900</td>
          <td>0.974918</td>
          <td>0.846184</td>
          <td>0.953915</td>
          <td>0.836942</td>
        </tr>
      </tbody>
    </table>
    </div>



Conclusions
-----------

**Signature score** is confirmed to be a powerful way to **condensate
the information of a whole gene signature expression** at single cell
level. The **only differenceres** from the expected score distributions
were **attributed to the high transcriptional similarity** (reported by
the authors themselves) **of some PBMC atlas cell group** (from which we
extracted the signatures), which have been previously defined also
exploiting protein level information. This further suggested the
**capability of this score to clearly highlight the goodness of the
transcriptional signature** itself.

**Signature based classification** resulted to be **effective in the
automatic annotation** of scRNA-seq datasets with external signatures.
In particular, considering the overall performances of CIA in the PBMC3K
test dataset:

-  our method is able to **rapidly classify a scRNA-seq dataset** using
   independent gene signatures and known negative markers **without any
   clustering step**.
-  **all the shown classification modalities** annotated cells with
   **good performances** (lowest ACC: 95.20%, lowest F1:83.21),
   suggesting that **fast classification can be used as explorative
   analysis to infer cell idendity** before a run with the more
   computationally intense FC-based mode.

In our package, besides the classification tool, we also implemented a
**module of functions** which allow to **easily compare classification
methods** and **evaluate score distributions** in cell groups (also
obtained with other packages).
